#!/usr/bin/env bash
# shellcheck disable=SC2016

# Example of using subshell so that env vars only have to be set once.
# (export TEST=42; bin/test.sh && bin/test.sh)

set -o errexit
set -o pipefail
[[ "${DEBUG}" == 'true' ]] && set -o xtrace

declare -r version='0.0.0'

function usage() {
  cat <<EOF
s3k ${version} - Do more with 'stack' by typing less!

USAGE
  s3k [OPTIONS] [--] [ARGS]

OPTIONS
  -p           Print the final command rather than executing it
  -b REGEX     Select build target(s) via extended regex
  -B REGEX     Same as '-b' but tests and benchmarks are not built
  -t REGEX     Select test target(s) via extended regex
  -T ARGS      Test arguments
                 (be sure to quote ARGS, e.g. -T '--match Foo')
  -r REGEX     Select run target(s) via extended regex
  -R ARGS      Run arguments
                 (be sure to quote ARGS, e.g. -R '-i foo.txt -o bar.txt')
  -g REGEX     Select GHCi target(s) via extended regex
  -G ARGS      GHCi options
                 (be sure to quote ARGS, e.g. -G '-Wno-missing-home-modules')
  -k WORD      Select haddock target(s) via extended regex
  -K ARGS      Haddock arguments
                 (be sure to quote ARGS, e.g. -K '--html --pretty-html')
  -m REGEX     Select benchmark target(s) via extended regex
  -M ARGS      Benchmark arguments
                 (be sure to quote ARGS, e.g. -M '--match pattern Foo')
  -l ALIAS     Load a project-specific command via alias
  -s ALIAS     Save the final command to a project-specific alias
  -e KEY=VAL   Use an environment variable in the final command
                 (this option may be specified multiple times)
  -W           Build without '--pedantic' flag
  -x CMD       Execute an arbitrary command if the generated command succeeds
                 (be sure to quote CMD)
  -C           Regenerate cached project info
  -V           Print version
  -h           Show help
  -H           Show verbose help

ARGS
  <STACK_ARG>  Additional arguments to pass to 'stack'

               Note that these args are passed to all 'stack'
               invocations in a generated command, not including
               possible 'stack' invocations specified directly by the
               user via '-x' or '-X'. A generated command will have
               multiple 'stack' invocations if at least two of the
               following options are present:

               -b, -B, -t, -r, -g, -k, -m

               Considering the above warning, it is typically only
               useful to supply STACK_ARG arguments when lasering in
               on a specific task with 's3k', whether that task is
               building, testing, running a binary, etc.

               If 's3k' is invoked with only STACK_ARG arguments and no
               options, then 's3k' is effectively a pass-through wrapper
               around 'stack' itself with a name that is two characters
               shorter.
EOF
}

function detailedUsage() {
  usage
  cat <<EOF

DETAILS

This script is a wrapper around 'stack'. STUB.

EXAMPLES

View the script's help:
$ s3k -h
EOF
}

function findJqOrDie() {
  local _jq=''
  if [ -x "${S3K_PATH_JQ}" ]; then
    _jq="${S3K_PATH_JQ}"
  elif command -v 'jq' &>/dev/null; then
    _jq='jq'
  else
    echo "s3k: 'jq' binary not found on runtime path or S3K_PATH_JQ" >&2
    exit 1
  fi

  echo "${_jq}"
}

function findStackOrDie() {
  local _stack=''
  if [ -x "${S3K_PATH_STACK}" ]; then
    _stack="${S3K_PATH_STACK}"
  elif command -v 'stack' &>/dev/null; then
    _stack='stack'
  else
    echo "s3k: 'stack' binary not found on runtime path or S3K_PATH_STACK" >&2
    exit 1
  fi

  echo "${_stack}"
}

function parseArgs() {
  local _jq="$1"
  shift 1

  local OPTARG
  local OPTIND
  local _opt

  local _execute='true'
  local _fullBuildTargetRegex=''
  local _buildTargetRegex=''
  local _testTargetRegex=''
  local _testArgs=''
  local _runTargetRegex=''
  local _runArgs=''
  local _ghciTargetRegex=''
  local _ghciArgs=''
  local _haddockTargetRegex=''
  local _haddockArgs=''
  local _benchTargetRegex=''
  local _benchArgs=''
  local _loadAlias=''
  local _saveAlias=''
  local _envVars=()
  local _buildWithPedanticFlag='true'
  local _arbitraryCommand=''
  local _regenProjectCache='false'
  local _printVersion='false'
  local _showUsage='false'
  local _showDetailedUsage='false'

  while getopts pb:B:t:T:r:R:g:G:k:K:m:M:l:s:e:Wx:CVhH _opt; do
    case "${_opt}" in
      p)
        _execute='false';;
      b)
        _fullBuildTargetRegex="${OPTARG}";;
      B)
        _buildTargetRegex="${OPTARG}";;
      t)
        _testTargetRegex="${OPTARG}";;
      T)
        _testArgs="${OPTARG}";;
      r)
        _runTargetRegex="${OPTARG}";;
      R)
        _runArgs="${OPTARG}";;
      g)
        _ghciTargetRegex="${OPTARG}";;
      G)
        _ghciArgs="${OPTARG}";;
      k)
        _haddockTargetRegex="${OPTARG}";;
      K)
        _haddockArgs="${OPTARG}";;
      m)
        _benchTargetRegex="${OPTARG}";;
      M)
        _benchArgs="${OPTARG}";;
      l)
        _loadAlias="${OPTARG}";;
      s)
        _saveAlias="${OPTARG}";;
      e)
        _envVars+=("${OPTARG}");;
      W)
        _buildWithPedanticFlag='false';;
      x)
        _arbitraryCommand="${OPTARG}";;
      C)
        _regenProjectCache='true';;
      V)
        _printVersion='true';;
      h)
        _showUsage='true';;
      H)
        _showDetailedUsage='true';;
      \?)
        usage >&2
        exit 1
        ;;
    esac
  done

  shift $((OPTIND - 1))

  if [ -z "${_testTargetRegex}" ] && [ -n "${_testArgs}" ]; then
    _testArgs=''
  fi

  if [ -z "${_runTargetRegex}" ] && [ -n "${_runArgs}" ]; then
    _runArgs=''
  fi

  if [ -z "${_ghciTargetRegex}" ] && [ -n "${_ghciArgs}" ]; then
    _ghciArgs=''
  fi

  if [ -z "${_haddockTargetRegex}" ] && [ -n "${_haddockArgs}" ]; then
    _haddockArgs=''
  fi

  if [ -z "${_benchTargetRegex}" ] && [ -n "${_benchArgs}" ]; then
    _benchArgs=''
  fi

  local _envVarsJSON='[]'
  if [ "${#_envVars[@]}" -gt 0 ]; then
    _envVarsJSON=$( \
      printf '%s\n' "${_envVars[@]}" | "$(findJqOrDie)" -nR \
        '[ inputs
         | split("=")
         | { key: .[0]
           , value: .[1:] | join("")
           }
         | select(
             (.key | test("^[A-Za-z][A-Za-z0-9_]*$")) and (.value | length > 0)
           )
         ]'
    )
  fi

  local _stackArgsJSON='[]'
  if [ "$#" -gt 0 ]; then
    _stackArgsJSON=$( \
      printf '%s\n' "$@" | jq -nR \
       '[ inputs
        | select(test("^\\s*$") | not)
        ]'
    )
  fi

  "${_jq}" -nS \
    --argjson execute "${_execute}"  \
    --arg fullBuildTargetRegex "${_fullBuildTargetRegex}" \
    --arg buildTargetRegex "${_buildTargetRegex}" \
    --arg testTargetRegex "${_testTargetRegex}" \
    --arg testArgs "${_testArgs}" \
    --arg runTargetRegex "${_runTargetRegex}" \
    --arg runArgs "${_runArgs}" \
    --arg ghciTargetRegex "${_ghciTargetRegex}" \
    --arg ghciArgs "${_ghciArgs}" \
    --arg haddockTargetRegex "${_haddockTargetRegex}" \
    --arg haddockArgs "${_haddockArgs}" \
    --arg benchTargetRegex "${_benchTargetRegex}" \
    --arg benchArgs "${_benchArgs}" \
    --arg loadAlias "${_loadAlias}" \
    --arg saveAlias "${_saveAlias}" \
    --argjson envVars "${_envVarsJSON}" \
    --argjson buildWithPedanticFlag "${_buildWithPedanticFlag}" \
    --arg arbitraryCommand "${_arbitraryCommand}" \
    --argjson regenProjectCache "${_regenProjectCache}" \
    --argjson printVersion "${_printVersion}" \
    --argjson showUsage "${_showUsage}" \
    --argjson showDetailedUsage "${_showDetailedUsage}" \
    --argjson stackArgs "${_stackArgsJSON}" '
      def nullIfEmptyString: if . == "" then null else . end;
      def emptyArrayIfEmptyString: if . == "" then [] else [.] end;
        .execute |= $execute
      | .fullBuildTargetRegex |= ($fullBuildTargetRegex | emptyArrayIfEmptyString)
      | .buildTargetRegex |= ($buildTargetRegex | emptyArrayIfEmptyString)
      | .testTargetRegex |= ($testTargetRegex | emptyArrayIfEmptyString)
      | .testArgs |= ($testArgs | emptyArrayIfEmptyString)
      | .runTargetRegex |= ($runTargetRegex | emptyArrayIfEmptyString)
      | .runArgs |= ($runArgs | emptyArrayIfEmptyString)
      | .ghciTargetRegex |= ($ghciTargetRegex | emptyArrayIfEmptyString)
      | .ghciArgs |= ($ghciArgs | emptyArrayIfEmptyString)
      | .haddockTargetRegex |= ($haddockTargetRegex | emptyArrayIfEmptyString)
      | .haddockArgs |= ($haddockArgs | emptyArrayIfEmptyString)
      | .benchTargetRegex |= ($benchTargetRegex | emptyArrayIfEmptyString)
      | .benchArgs |= ($benchArgs | emptyArrayIfEmptyString)
      | .loadAlias |= ($loadAlias | nullIfEmptyString)
      | .saveAlias |= ($saveAlias | nullIfEmptyString)
      | .envVars |= $envVars
      | .buildWithPedanticFlag |= $buildWithPedanticFlag
      | .arbitraryCommand |= ($arbitraryCommand | emptyArrayIfEmptyString)
      | .regenProjectCache |= $regenProjectCache
      | .printVersion |= $printVersion
      | .showUsage |= $showUsage
      | .showDetailedUsage |= $showDetailedUsage
      | .stackArgs |= $stackArgs
      '
}

function shouldShowUsage() {
  local _jq="$1"
  local _opts="$2"

  "${_jq}" -e '.showUsage' > /dev/null <<< "${_opts}"
}

function showUsage() {
  usage
  exit 0
}

function shouldShowDetailedUsage() {
  local _jq="$1"
  local _opts="$2"

  "${_jq}" -e '.showDetailedUsage' > /dev/null <<< "${_opts}"
}

function showDetailedUsage() {
  detailedUsage
  exit 0
}

function shouldPrintVersion() {
  local _jq="$1"
  local _opts="$2"

  "${_jq}" -e '.printVersion' > /dev/null <<< "${_opts}"
}

function printVersion() {
  echo "${version}"
  exit 0
}

function findConfigFile() {
  local _jq="$1"

  local _configHome=''
  if [ -f "${S3K_CONFIG_HOME}" ]; then
    _configHome="${S3K_CONFIG_HOME}"
  elif [ -d "${XDG_CONFIG_HOME}" ]; then
    _configHome="${XDG_CONFIG_HOME}/s3k"
  elif [ -d "${HOME}" ]; then
    _configHome="${HOME}/.s3k"
  else
    echo "s3k: Unable to find config dir. You can declare a dir via S3K_CONFIG_HOME?" >&2
    exit 1
  fi

  mkdir -p "${_configHome}"

  local _configFile
  _configFile="${_configHome}/config.json"

  if [ ! -f "${_configFile}" ]; then
    "${_jq}" -S '.createdAt |= (now | todateiso8601)' \
      <<< '{"createdAt": null, "projects": {}}' \
      > "${_configFile}"
  fi

  echo "${_configFile}"
}

function addProjectToConfigFile() {
  local _jq="$1"
  local _configFile="$2"
  local _projRoot="$3"

  local _cacheDirName=''

  local _tempFile
  _tempFile="$(mktemp)"
  cp "${_configFile}" "${_tempFile}"

  if ! "${_jq}" -e --arg projKey "${_projRoot}" '.projects | has($projKey)' \
    > /dev/null < "${_tempFile}"; then
    # TODO: Needs MacOS compatibility (md5sum vs md5)
    _cacheDirName="$(echo "${_projRoot}" | tr -d '\n' | md5sum | cut -d ' ' -f1)"
    "${_jq}" -S --arg projKey "${_projRoot}" --arg cacheDirName "${_cacheDirName}" '
      .projects += {
        ($projKey): {
          "aliases": {},
          "cacheDirName": $cacheDirName
        }
      }' > "${_configFile}" < "${_tempFile}"
  fi
}

function findCacheDir() {
  local _jq="$1"
  local _configFile="$2"
  local _projRoot="$3"

  local _cacheDirName
  _cacheDirName=$(
    "${_jq}" -re --arg projRoot "${_projRoot}" \
      '.projects[$projRoot].cacheDirName' \
      < "${_configFile}" \
  )

  local _cacheDir
  _cacheDir="$(dirname "${_configFile}")/cache/${_cacheDirName}"

  mkdir -p "${_cacheDir}"
  echo "${_cacheDir}"
}

shouldRegenProjectCache() {
  local _jq="$1"
  local _opts="$2"
  local _cacheDir="$3"

  if [ -z "$(ls -A "${_cacheDir}")" ]; then
    true
  else
    "${_jq}" -e '.regenProjectCache' > /dev/null <<< "${_opts}"
  fi
}

function regenProjectCache() {
  local _jq="$1"
  local _cacheDir="$2"

  echo "REGENERATING PROJECT CACHE"
  stack ide packages --stdout \
    | sort \
    > "${_cacheDir}/build-targets"

  stack ide targets --stdout \
    | awk -F ':' '($2 == "test"){print $1}' \
    | sort -u \
    > "${_cacheDir}/test-targets"

  stack ide targets --stdout \
    | awk -F ':' '($2 == "bench"){print $1}' \
    | sort -u \
    > "${_cacheDir}/bench-targets"

  stack ide targets --stdout \
    | awk -F ':' '($2 == "exe"){print $3}' \
    | sort \
    > "${_cacheDir}/run-targets"

  stack ide targets --stdout \
    | sort \
    > "${_cacheDir}/ghci-targets"
}

function loadAlias() {
  local _jq="$1"
  local _opts="$2"

  "${_jq}" \
    '.loadAlias //
       {
         "fullBuildTargetRegex": [],
         "buildTargetRegex": [],
         "testTargetRegex": [],
         "testArgs": [],
         "runTargetRegex": [],
         "runArgs": [],
         "ghciTargetRegex": [],
         "ghciArgs": [],
         "haddockTargetRegex": [],
         "haddockArgs": [],
         "benchTargetRegex": [],
         "benchArgs": [],
         "envVars": [],
         "buildWithPedanticFlag": false,
         "arbitraryCommand": [],
         "stackArgs": []
       }
    ' <<< "${_opts}"
}

function shouldSaveAlias() {
  # TODO: Implement me!
  return 1
}

function saveAlias() {
  # TODO: Implement me!
  echo "saving alias!"
  return 0
}

function processCommandList() {
  local _jq="$1"
  local _opts="$2"
  local _cacheDir="$3"

  local _finalCommand=()
  local _line

  local _buildWithPedanticFlag=''
  _buildWithPedanticFlag=$(
    "${_jq}" '.buildWithPedanticFlag // empty' <<< "${_opts}"
  )

  local _stackArgs=()
  while IFS='' read -r _line; do
    _stackArgs+=("${_line}")
  done < <(jq -r '.stackArgs[]' <<< "${_opts}")

  local _buildCommand=('stack' 'build')

  if [ -n "${_buildWithPedanticFlag}" ]; then
    _buildCommand+=('--pedantic')
  fi

  local _buildTargets=()
  local _buildTargetRegex=()
  while IFS='' read -r _line; do
    _buildTargetRegex+=("${_line}")
  done < <(jq -r '.buildTargetRegex[]' <<< "${_opts}")
  if [ "${#_buildTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _buildTargets+=("${_line}")
    done < <( \
      grep -Ef <(printf '%s\n' "${_buildTargetRegex[@]}") "${_cacheDir}/build-targets"
    )

    if [ "${#_buildTargets[@]}" -gt 0 ]; then
      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_buildCommand[@]}" "${_stackArgs[@]}" "${_buildTargets[@]}")
      else
        _finalCommand+=("${_buildCommand[@]}" "${_buildTargets[@]}")
      fi
    fi
  fi
  local _fullBuildCommand=(
    'stack' 'build' '--test' '--no-run-tests' '--bench' '--no-run-benchmarks'
  )
  if [ -n "${_buildWithPedanticFlag}" ]; then
    _fullBuildCommand+=('--pedantic')
  fi
  local _fullBuildTargets=()
  local _fullBuildTargetRegex=()
  while IFS='' read -r _line; do
    _fullBuildTargetRegex+=("${_line}")
  done < <(jq -r '.fullBuildTargetRegex[]' <<< "${_opts}")

  if [ "${#_fullBuildTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _fullBuildTargets+=("${_line}")
    done < <( \
      grep -Ef <(printf '%s\n' "${_fullBuildTargetRegex[@]}") "${_cacheDir}/build-targets"
    )

    if [ "${#_fullBuildTargets[@]}" -gt 0 ]; then
      if [ "${#_finalCommand[@]}" -gt 0 ]; then
        _finalCommand+=('&&')
      fi

      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_fullBuildCommand[@]}" "${_stackArgs[@]}" "${_fullBuildTargets[@]}")
      else
        _finalCommand+=("${_fullBuildCommand[@]}" "${_fullBuildTargets[@]}")
      fi
    fi
  fi

  local _testCommand=('stack' 'test')
  if [ -n "${_buildWithPedanticFlag}" ]; then
    _testCommand+=('--pedantic')
  fi
  local _testArgs=''
  _testArgs=$(jq -r '.testArgs | if . == [] then empty else join (" ") | @sh end' <<< "${_opts}")
  if [ -n "${_testArgs}" ]; then
    _testCommand+=('--test-arguments' "${_testArgs}")
  fi
  local _testTargets=()
  local _testTargetRegex=()
  while IFS='' read -r _line; do
    _testTargetRegex+=("${_line}")
  done < <(jq -r '.testTargetRegex[]' <<< "${_opts}")

  if [ "${#_testTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _testTargets+=("${_line}")
    done < <( \
      grep -Ef <(printf '%s\n' "${_testTargetRegex[@]}") "${_cacheDir}/test-targets"
    )

    if [ "${#_testTargets[@]}" -gt 0 ]; then
      if [ "${#_finalCommand[@]}" -gt 0 ]; then
        _finalCommand+=('&&')
      fi

      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_testCommand[@]}" "${_stackArgs[@]}" "${_testTargets[@]}")
      else
        _finalCommand+=("${_testCommand[@]}" "${_testTargets[@]}")
      fi
    fi
  fi

  local _haddockCommand=('stack' 'haddock')
  if [ -n "${_buildWithPedanticFlag}" ]; then
    _haddockCommand+=('--pedantic')
  fi
  local _haddockArgs=''
  _haddockArgs=$(jq -r '.haddockArgs | if . == [] then empty else join (" ") | @sh end' <<< "${_opts}")
  if [ -n "${_haddockArgs}" ]; then
    _haddockCommand+=('--haddock-arguments' "${_haddockArgs}")
  fi
  local _haddockTargets=()
  local _haddockTargetRegex=()
  while IFS='' read -r _line; do
    _haddockTargetRegex+=("${_line}")
  done < <(jq -r '.haddockTargetRegex[]' <<< "${_opts}")

  if [ "${#_haddockTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _haddockTargets+=("${_line}")
    done < <( \
      grep -Ef <(printf '%s\n' "${_haddockTargetRegex[@]}") "${_cacheDir}/build-targets"
    )

    if [ "${#_haddockTargets[@]}" -gt 0 ]; then
      if [ "${#_finalCommand[@]}" -gt 0 ]; then
        _finalCommand+=('&&')
      fi

      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_haddockCommand[@]}" "${_stackArgs[@]}" "${_haddockTargets[@]}")
      else
        _finalCommand+=("${_haddockCommand[@]}" "${_haddockTargets[@]}")
      fi
    fi
  fi

  local _benchCommand=('stack' 'bench')
  if [ -n "${_buildWithPedanticFlag}" ]; then
    _benchCommand+=('--pedantic')
  fi
  local _benchArgs=''
  _benchArgs=$(jq -r '.benchArgs | if . == [] then empty else join (" ") | @sh end' <<< "${_opts}")
  if [ -n "${_benchArgs}" ]; then
    _benchCommand+=('--bench-arguments' "${_benchArgs}")
  fi
  local _benchTargets=()
  local _benchTargetRegex=()
  while IFS='' read -r _line; do
    _benchTargetRegex+=("${_line}")
  done < <(jq -r '.benchTargetRegex[]' <<< "${_opts}")

  if [ "${#_benchTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _benchTargets+=("${_line}")
    done < <( \
      grep -Ef <(printf '%s\n' "${_benchTargetRegex[@]}") "${_cacheDir}/bench-targets"
    )

    if [ "${#_benchTargets[@]}" -gt 0 ]; then
      if [ "${#_finalCommand[@]}" -gt 0 ]; then
        _finalCommand+=('&&')
      fi

      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_benchCommand[@]}" "${_stackArgs[@]}" "${_benchTargets[@]}")
      else
        _finalCommand+=("${_benchCommand[@]}" "${_benchTargets[@]}")
      fi
    fi
  fi

  local _runCommand=('stack' 'run')
  local _runArgs=''
  _runArgs=$(jq -r '.runArgs | if . == [] then empty else join (" ") | @sh end' <<< "${_opts}")
  local _runTarget=''
  local _runTargetRegex=()
  while IFS='' read -r _line; do
    _runTargetRegex+=("${_line}")
  done < <(jq -r '.runTargetRegex[]' <<< "${_opts}")
  if [ "${#_runTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _runTarget="${_line}"
      if [ "${#_finalCommand[@]}" -gt 0 ]; then
        _finalCommand+=('&&')
      fi

      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_runCommand[@]}" "${_stackArgs[@]}" "${_runTarget}")
      else
        _finalCommand+=("${_runCommand[@]}" "${_runTarget}")
      fi

      if [ -n "${_runArgs}" ]; then
        _finalCommand+=('--' "${_runArgs[@]}")
      fi
    done < <( \
      grep -Ef <(printf '%s\n' "${_runTargetRegex[@]}") "${_cacheDir}/run-targets"
    )
  fi

  local _ghciCommand=('stack' 'ghci')
  local _ghciArgs=''
  _ghciArgs=$(jq -r '.ghciArgs | if . == [] then empty else join (" ") | @sh end' <<< "${_opts}")
  if [ -n "${_ghciArgs}" ]; then
    _ghciCommand+=('--ghci-options' "${_ghciArgs}")
  fi
  local _ghciTargets=()
  local _ghciTargetRegex=()
  while IFS='' read -r _line; do
    _ghciTargetRegex+=("${_line}")
  done < <(jq -r '.ghciTargetRegex[]' <<< "${_opts}")

  if [ "${#_ghciTargetRegex[@]}" -gt 0 ]; then
    while IFS='' read -r _line; do
      _ghciTargets+=("${_line}")
    done < <( \
      grep -Ef <(printf '%s\n' "${_ghciTargetRegex[@]}") "${_cacheDir}/ghci-targets"
    )

    if [ "${#_ghciTargets[@]}" -gt 0 ]; then
      if [ "${#_finalCommand[@]}" -gt 0 ]; then
        _finalCommand+=('&&')
      fi

      if [ "${#_stackArgs[@]}" -gt 0 ]; then
        _finalCommand+=("${_ghciCommand[@]}" "${_stackArgs[@]}" "${_ghciTargets[@]}")
      else
        _finalCommand+=("${_ghciCommand[@]}" "${_ghciTargets[@]}")
      fi
    fi
  fi

  local _arbitraryCommand=''
  while IFS='' read -r _line; do
    _arbitraryCommand="${_line}"
    if [ "${#_finalCommand[@]}" -gt 0 ]; then
      _finalCommand+=('&&')
    fi
    _finalCommand+=("${_arbitraryCommand}")
  done < <(jq -r '.arbitraryCommand[]' <<< "${_opts}")

  local _envVars=()
  while IFS='' read -r _line; do
    _envVars+=("${_line}")
  done < <(jq -r '.envVars[] | "export \(.key)=\(.value | @sh);"' <<< "${_opts}")
  if [ "${#_envVars[@]}" -gt 0 ]; then
    _finalCommand=('(' "${_envVars[@]}" "${_finalCommand[@]}" ')')
  fi

  if "${_jq}" -e '.execute' > /dev/null <<< "${_opts}"; then
    eval "${_finalCommand[*]}"
  else
    echo "${_finalCommand[*]}"
  fi
}

function main() {
  local _jq
  _jq="$(findJqOrDie)"

  local _stack
  _stack="$(findStackOrDie)"

  local _projRoot
  _projRoot="$("${_stack}" path --project-root 2>/dev/null)"

  local _opts
  _opts="$(parseArgs "${_jq}" "$@")"

  shouldShowDetailedUsage "${_jq}" "${_opts}" \
    && showDetailedUsage
  shouldShowUsage "${_jq}" "${_opts}" \
    && showUsage
  shouldPrintVersion "${_jq}" "${_opts}" \
    && printVersion

  local _configFile
  _configFile="$(findConfigFile "${_jq}")"

  addProjectToConfigFile "${_jq}" "${_configFile}" "${_projRoot}"

  local _cacheDir
  _cacheDir=$(findCacheDir "${_jq}" "${_configFile}" "${_projRoot}")

  shouldRegenProjectCache "${_jq}" "${_opts}" "${_cacheDir}" \
    && regenProjectCache "${_jq}" "${_cacheDir}"

  loadAlias "${_jq}" "${_opts}"
  shouldSaveAlias && saveAlias # TODO: Functions aren't implemented yet!

  processCommandList "${_jq}" "${_opts}" "${_cacheDir}"

  #jq < "$(findConfigFile "${_jq}")"
  jq <<< "${_opts}"
}

main "$@"
